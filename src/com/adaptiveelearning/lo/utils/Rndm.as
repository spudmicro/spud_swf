package com.adaptiveelearning.lo.utils {	import flash.display.BitmapData;		// Provides common random functions using a seeded random system. Can be used through static interface or via instantiation.		public class Rndm {	// static interface:		// NOTE: for usage information, look at the instance methods below.			protected static var _instance:Rndm;		public static function get instance():Rndm {			if (_instance == null) { _instance = new Rndm(); }			return _instance;		}				public static function get seed():uint {			return instance.seed;		}		public static function set seed(value:uint):void {			instance.seed = value;		}				public static function get currentSeed():uint {			return instance.currentSeed;		}				public static function random():Number {			return instance.random();		}				public static function float(min:Number,max:Number=NaN,div:Number=NaN):Number {			return instance.float(min,max,div);		}				public static function boolean(chance:Number=0.5):Boolean {			return instance.boolean(chance);		}				public static function sign(chance:Number=0.5):int {			return instance.sign(chance);		}				public static function bit(chance:Number=0.5):int {			return instance.bit(chance);		}				public static function integer(min:Number,max:Number=NaN,div:Number=NaN):int {			return instance.integer(min,max,div);		}				public static function reset():void {			instance.reset();		}					// constants:	// private properties:		protected var _seed:uint=0;		protected var _currentSeed:uint=0;		// public properties:			// constructor:		public function Rndm(seed:uint=1) {			_seed = _currentSeed = seed;		}						public function initialize(seed:uint=1):void {			this.seed = seed;			random(); 		} 			// public getter/setters:			// seed = Math.random()*0xFFFFFF; // sets a random seed		// seed = 50; // sets a static seed		public function get seed():uint {			return _seed;		}		public function set seed(value:uint):void {			_seed = _currentSeed = value;		}				// gets the current seed		public function get currentSeed():uint {			return _currentSeed;		}		// public methods:		// random(); // returns a number between 0-1 exclusive.		public function random():Number {			return (_currentSeed = (_currentSeed * 16807) % 2147483647)/0x7FFFFFFF+0.000000000233;		}				// float(50); // returns a number between 0-50 exclusive		// float(20,50); // returns a number between 20-50 exclusive		public function float(min:Number,max:Number=NaN,div:Number=NaN):Number {			if (isNaN(max)) { max = min; min=0; }			if (isNaN(div)) {				 return random()*(max-min)+min;			} else {				return Math.round(random()*(max-min)/div)*div+min;			}		}				// boolean(); // returns true or false (50% chance of true)		// boolean(0.8); // returns true or false (80% chance of true)		public function boolean(chance:Number=0.5):Boolean {			return (random() < chance);		}				// sign(); // returns 1 or -1 (50% chance of 1)		// sign(0.8); // returns 1 or -1 (80% chance of 1)		public function sign(chance:Number=0.5):int {			return (random() < chance) ? 1 : -1;		}				// bit(); // returns 1 or 0 (50% chance of 1)		// bit(0.8); // returns 1 or 0 (80% chance of 1)		public function bit(chance:Number=0.5):int {			return (random() < chance) ? 1 : 0;		}				// integer(50); // returns an integer between 0-49 inclusive		// integer(20,50); // returns an integer between 20-49 inclusive		public function integer(min:Number,max:Number=NaN,div:Number=NaN):int {			if (isNaN(max)) { max = min; min=0; }			// Need to use floor instead of bit shift to work properly with negative values:			return Math.floor(float(min,max,div));		}				// reset(); // resets the number series, retaining the same seed		public function reset():void {			_seed = _currentSeed;		}						private var haveNextNextGaussian:Boolean;		private var nextNextGaussian:Number;						public function nextGaussian():Number {	    	if (haveNextNextGaussian) {	            haveNextNextGaussian = false;	           	return nextNextGaussian;	    	} else {				var v1:Number, v2:Number, s:Number;		    	do { 	                v1 = 2 * this.random() - 1;   // between -1.0 and 1.0	                v2 = 2 * this.random() - 1;   // between -1.0 and 1.0	                s = v1 * v1 + v2 * v2;	                if (s==2) {	                	return 2;	                }	       		} while (s >= 1 || s == 0);				var multiplier:Number = Math.sqrt(-2 * Math.log(s)/s);				nextNextGaussian = v2 * multiplier;		    	haveNextNextGaussian = true;		    	return v1 * multiplier;			}		}											// private methods:	}}